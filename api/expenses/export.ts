import type { NextApiRequest, NextApiResponse } from 'next';
import { authenticateUser } from '../_lib/auth';
import { db } from '../_lib/database';
import { expenses, users } from '../_lib/schema';
import { eq, and } from 'drizzle-orm';
import { closeConnection } from '../_lib/database';
import { format } from 'date-fns';
import ExcelJS from 'exceljs';
import archiver from 'archiver';
import { createReadStream } from 'fs';
import path from 'path';
import { createClient } from '@supabase/supabase-js';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Only allow GET requests
  if (req.method !== 'GET') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  try {
    // Authenticate user
    const user = await authenticateUser(req);
    
    if (!user) {
      return res.status(401).json({ message: 'Unauthorized' });
    }

    const tripName = req.query.tripName as string | undefined;
    const dateSuffix = format(new Date(), 'yyyyMMdd');
    const safeTripName = tripName ? tripName.replace(/[^a-z0-9]/gi, '_').toLowerCase() : 'all';
    const zipFilename = `expense-export-${safeTripName}-${dateSuffix}.zip`;
    const excelFilename = `expenses-${safeTripName}-${dateSuffix}.xlsx`;

    // Get expenses
    let userExpenses;
    if (tripName) {
      userExpenses = await db.select()
        .from(expenses)
        .where(and(
          eq(expenses.userId, user.id),
          eq(expenses.tripName, tripName)
        ))
        .orderBy(expenses.date);
    } else {
      userExpenses = await db.select()
        .from(expenses)
        .where(eq(expenses.userId, user.id))
        .orderBy(expenses.date);
    }

    // Set headers for ZIP download
    res.setHeader('Content-Type', 'application/zip');
    res.setHeader('Content-Disposition', `attachment; filename=${zipFilename}`);

    // Initialize archiver
    const archive = archiver('zip', {
      zlib: { level: 9 } // Sets the compression level.
    });

    // Pipe archive data to the response
    archive.pipe(res);

    // Handle warnings and errors
    archive.on('warning', function(err) {
      if (err.code === 'ENOENT') {
        console.warn("Archiver warning: ", err); // Log file not found warnings
      } else {
        // Throw error for other warnings
        throw err;
      }
    });
    
    archive.on('error', function(err) {
      console.error("Archiving error:", err);
      // Ensure response ends if headers not sent
      if (!res.headersSent) {
        res.status(500).send({ error: 'Failed to create zip file.' });
      }
    });

    // --- Generate Excel ---
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Expenses');

    // Add header row
    worksheet.columns = [
      { header: 'Date', key: 'date', width: 15 },
      { header: 'Vendor', key: 'vendor', width: 20 },
      { header: 'Location', key: 'location', width: 20 },
      { header: 'Type', key: 'type', width: 15 },
      { header: 'Amount', key: 'cost', width: 15 },
      { header: 'Trip', key: 'tripName', width: 20 },
      { header: 'Comments', key: 'comments', width: 30 },
      { header: 'Receipt', key: 'receipt', width: 20 },
    ];

    // Style header row
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' }
    };

    // Add expense data
    userExpenses.forEach((expense, index) => {
      worksheet.addRow({
        date: expense.date,
        vendor: expense.vendor,
        location: expense.location,
        type: expense.type,
        cost: parseFloat(expense.cost),
        tripName: expense.tripName,
        comments: expense.comments || '',
        receipt: expense.receiptPath ? `receipts/${path.basename(expense.receiptPath)}` : 'No receipt'
      });

      // Format cost column as currency
      worksheet.getCell(`E${index + 2}`).numFmt = '$#,##0.00';
    });

    // Add summary section
    const summaryRowIndex = userExpenses.length + 3;
    worksheet.addRow([]);
    worksheet.addRow(['Summary']);
    worksheet.getCell(`A${summaryRowIndex}`).font = { bold: true, size: 14 };

    // Add total
    const totalRowIndex = summaryRowIndex + 1;
    worksheet.addRow(['Total', '', '', '', `=SUM(E2:E${userExpenses.length + 1})`]);
    worksheet.getCell(`A${totalRowIndex}`).font = { bold: true };
    worksheet.getCell(`E${totalRowIndex}`).font = { bold: true };
    worksheet.getCell(`E${totalRowIndex}`).numFmt = '$#,##0.00';

    // Add user info
    const userRowIndex = totalRowIndex + 2;
    worksheet.addRow(['Generated by:', user.firstName + ' ' + user.lastName]);
    worksheet.addRow(['Date:', format(new Date(), 'yyyy-MM-dd')]);
    worksheet.getCell(`A${userRowIndex}`).font = { bold: true };
    worksheet.getCell(`A${userRowIndex + 1}`).font = { bold: true };

    // Write Excel to buffer
    const excelBuffer = await workbook.xlsx.writeBuffer();

    // Add Excel to ZIP
    archive.append(Buffer.from(excelBuffer), { name: excelFilename });
    console.log(`Appended ${excelFilename} to archive.`);

    // --- Add Receipts to ZIP ---
    // Initialize Supabase client for downloading receipts
    const supabaseUrl = process.env.SUPABASE_URL;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;
    
    if (!supabaseUrl || !supabaseServiceKey) {
      console.error('Missing Supabase environment variables');
      throw new Error('Storage configuration is missing');
    }
    
    const supabase = createClient(supabaseUrl, supabaseServiceKey);
    
    // Add receipts to the archive
    for (const expense of userExpenses) {
      if (expense.receiptPath) {
        try {
          // Extract bucket and path from the URL
          const receiptUrl = expense.receiptPath;
          const url = new URL(receiptUrl);
          const pathParts = url.pathname.split('/');
          
          // The bucket name should be the first part after /storage/v1/object/public/
          const bucketIndex = pathParts.findIndex(part => part === 'public') + 1;
          if (bucketIndex >= pathParts.length) {
            console.error('Invalid receipt URL format');
            continue;
          }
          
          const bucket = pathParts[bucketIndex];
          // The file path is everything after the bucket name
          const filePath = pathParts.slice(bucketIndex + 1).join('/');
          
          if (!bucket || !filePath) {
            console.error('Could not extract bucket or file path from URL');
            continue;
          }
          
          // Download the file from Supabase
          const { data, error } = await supabase.storage.from(bucket).download(filePath);
          
          if (error) {
            console.error(`Error downloading receipt ${filePath}:`, error);
            continue;
          }
          
          // Add the file to the archive
          const fileName = path.basename(filePath);
          // Convert Blob to Buffer
          const arrayBuffer = await data.arrayBuffer();
          const buffer = Buffer.from(arrayBuffer);
          archive.append(buffer, { name: `receipts/${fileName}` });
          console.log(`Added receipt: ${fileName}`);
        } catch (error) {
          console.error(`Error processing receipt ${expense.receiptPath}:`, error);
        }
      }
    }

    // Finalize the archive
    await archive.finalize();
    console.log("Archive finalized.");
  } catch (error) {
    console.error("Error during export:", error);
    // Ensure response ends if headers not sent
    if (!res.headersSent) {
      res.status(500).json({ error: 'Failed to generate export file.' });
    }
  } finally {
    // Close database connection in production
    await closeConnection();
  }
}